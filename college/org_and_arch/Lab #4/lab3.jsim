***.include "C:\Users\eviebroc\Desktop\ECPE173\JSIM\Library_Files\nominal.jsim"
***.include "C:\Users\eviebroc\Desktop\ECPE173\JSIM\Library_Files\stdcell.jsim"
***.include "C:\Users\eviebroc\Desktop\ECPE173\Lab_3\lab3checkoff_1.jsim"


.subckt BOOL alufn[3:0] A[31:0] B[31:0] OUT[31:0]
***xdummy OUT[31:0] constant0
***Xand A[31:0] B[31:0] andOUT[31:0] and32
***Xor A[31:0] B[31:0] orOUT[31:0] or32
***Xxor A[31:0] B[31:0] xorOUT[31:0] xor32
***Xa A[31:0] B[31:0] aOUT[31:0] buffer_32
***Xmux1 alufn[1] alufn[0] 0 0 0 0 z_a mux4
***Xmux2 alufn[1] alufn[0] 0 0 xorOUT 0 z_b mux4
***Xmux3 alufn[1] alufn[0] andOUT 0 aOUT 0 z_c mux4
***Xmux4 alufn[1] alufn[0] 0 0 orOUT 0 z_d mux4
***Xmux5 alufn[3] alufn[2] z_a z_b z_c z_d z_e mux4
Xmux4 A[31:0] B[31:0] alufn[0]#32 alufn[1]#32 alufn[2]#32 alufn[3]#32 OUT[31:0] mux4
.ends

.subckt ARITH alufn[1:0] A[31:0] B[31:0] OUT[31:0] Z V N
Xxor_a B[31:0] alufn[0]#32 xorOUT_a[31:0] xor2
Xxor_b A[31:0] xorOUT_a[31:0] xorOUT_b[31:0] xor2
Xxor_c xorOUT_b[31:0] Cout[30:0] alufn[0] OUT[31:0] xor2
Xand_a xorOUT_b[31:0] Cout[30:0] alufn[0] andOUT_a[31:0] and2
Xand_b A[31:0] xorOUT_a[31:0] andOUT_b[31:0] and2
Xor andOUT_a[31:0] andOUT_b[31:0] Cout[31:0] or2
*** Z = true when output S is zero ***
Xz_a OUT[3:0] zOUT_a nor4
Xz_b OUT[7:4] zOUT_b nor4
Xz_c OUT[11:8] zOUT_c nor4
Xz_d OUT[15:12] zOUT_d nor4
Xz_e zOUT_a zOUT_b zOUT_c zOUT_d zOUT_e and4
Xz_f OUT[19:16] zOUT_f nor4
Xz_g OUT[23:20] zOUT_g nor4
Xz_h OUT[27:24] zOUT_h nor4
Xz_i OUT[31:28] zOUT_i nor4
Xz_j zOUT_f zOUT_g zOUT_h zOUT_i zOUT_j and4
Xz_k zOUT_e zOUT_j Z and2
*** V = true when there is an overflow ***
Xv_a A[31] xorOUT_a[31] vOUT_a nor2
Xv_b vOUT_a OUT[31] vOUT_b and2
Xv_c A[31] xorOUT_a[31] vOUT_c and2
Xv_d OUT[31] VDD vOUT_d xor2
Xv_e vOUT_c vOUT_d vOUT_e and2
Xv_f vOUT_b vOUT_e V or2
*** N = true when S is negative ***
Xn OUT[31] 0 N or2
.ends

.subckt SHIFT alufn[1:0] A[31:0] B[31:0] OUT[31:0]
*** shift left ***
Xshift_mux_la B[0]#32 A[31:0] A[30:0] 0 shift_muxOUT_la[31:0] mux2
Xshift_mux_lb B[1]#32 shift_muxOUT_la[31:0] shift_muxOUT_la[29:0] 0#2 shift_muxOUT_lb[31:0] mux2
Xshift_mux_lc B[2]#32 shift_muxOUT_lb[31:0] shift_muxOUT_lb[27:0] 0#4 shift_muxOUT_lc[31:0] mux2
Xshift_mux_ld B[3]#32 shift_muxOUT_lc[31:0] shift_muxOUT_lc[23:0] 0#8 shift_muxOUT_ld[31:0] mux2
Xshift_mux_le B[4]#32 shift_muxOUT_ld[31:0] shift_muxOUT_ld[15:0] 0#16 shift_left[31:0] mux2
*** shift right ***
Xshift_mux_ra B[0]#32 A[31:0] 0 A[31:1] shift_muxOUT_a[31:0] mux2
Xshift_mux_rb B[1]#32 shift_muxOUT_a[31:0] 0#2 shift_muxOUT_a[31:2] shift_muxOUT_b[31:0] mux2
Xshift_mux_rc B[2]#32 shift_muxOUT_b[31:0] 0#4 shift_muxOUT_b[31:4] shift_muxOUT_c[31:0] mux2
Xshift_mux_rd B[3]#32 shift_muxOUT_c[31:0] 0#8 shift_muxOUT_c[31:8] shift_muxOUT_d[31:0] mux2
Xshift_mux_re B[4]#32 shift_muxOUT_d[31:0] 0#16 shift_muxOUT_d[31:16] shift_right[31:0] mux2
*** shift right, sign extended ***
Xshift_mux_raa B[0]#32 A[31:0] A[31] A[31:1] shift_muxOUT_aa[31:0] mux2
Xshift_mux_rab B[1]#32 shift_muxOUT_aa[31:0] A[31]#2 shift_muxOUT_aa[31:2] shift_muxOUT_ba[31:0] mux2
Xshift_mux_rac B[2]#32 shift_muxOUT_ba[31:0] A[31]#4 shift_muxOUT_ba[31:4] shift_muxOUT_ca[31:0] mux2
Xshift_mux_rad B[3]#32 shift_muxOUT_ca[31:0] A[31]#8 shift_muxOUT_ca[31:8] shift_muxOUT_da[31:0] mux2
Xshift_mux_rae B[4]#32 shift_muxOUT_da[31:0] A[31]#16 shift_muxOUT_da[31:16] shift_rightext[31:0] mux2
Xshift_mux alufn[0]#32 alufn[1]#32 shift_left[31:0] shift_right[31:0] 0#32 shift_rightext[31:0] OUT[31:0] mux4
.ends

.subckt CMP alufn3 alufn1 Z V N OUT[31:0]
*** equal ***
Xequal 0 Z equalOUT or2
*** less than ***
Xlthan V N lthanOUT xor2
*** less than or equal ***
Xlte N Z lteOUT or2
Xout_inv OUT[31:1] constant0
Xcmp_mux alufn[1] alufn[3] equalOUT lthanOUT lteOUT 0 OUT[0] mux4
.ends

.subckt alu alufn[4:0] a[31:0] b[31:0] out[31:0] z v n

*** Generate outputs from each of BOOL, SHIFT, ARITH, CMP subcircuits:
xbool alufn[3:0] a[31:0] b[31:0] boolout[31:0] BOOL
xshift alufn[1:0] a[31:0] b[31:0] shiftout[31:0] SHIFT
xarith alufn[1:0] a[31:0] b[31:0] arithout[31:0] z v n ARITH
xcmp alufn[3] alufn[1] z v n cmpout[31:0] CMP

*** Combine them, using three multiplexors:
xmux1 alufn[4]#32 nonbool[31:0] boolout[31:0] out[31:0] mux2
xmux2 alufn[2]#32 arithshift[31:0] cmpout[31:0] nonbool[31:0] mux2
xmux3 alufn[3]#32 arithout[31:0] shiftout[31:0] arithshift[31:0] mux2
.ends